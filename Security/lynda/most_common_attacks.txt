# Types of Credentials attacks
    - Brute force attack
        maximum time required for brute-force attack is
        (Possibilities count ^ password length * time per attempt)
    - Dictionary attack (Prioritize the Dictionary word)
    - Credentials stuffing (common password accross the website)

# Strong Passwords

    - Use long passwords (12 characters minimum)
    - use character variety (A-Z, a-z, 0-9, symbols)
    - avoid patterns and Dictionary words
    - common mistake is short complex password is more secure than long simple one
    - Don't reuse password
    - Use password manager (LastPass, 1Password, Dashlane, KeePass)
    - Use ssh keys
    - two factor authentication
    - Use password hashing
    - Login Throttling (5 min wait after 10 failed attempts, prevent brute force attack)

# URL manipulation and insecure direct object reference (IDOR)

    * Url Manipulation
    - Searching for private webpages
    - Exploring the file system
    - Enumerating values in the database
    - Detecting installed software

    * Direct object reference
    - Database data
    - Files
    - Directories
    - Scripts
    - Functions

    * Preventing Insecure Direct object references
    - urls are exposed and easily editable
    - consider edge cases (expect the unexpected)
    - Use allow-lists for acceptable parameters 
    - Handle errors gracefully and vaguely
    - Use access control for privileged pages and actions
    - Change the direct object reference to an indirect 
    
# SQL injection
    
    * Solutions to sql injection
    - Limit the application's database privileges
    - Limit permission to create, drop, or truncate tables
    - Don't grant access privileges to database users
    - Never let the application connect as the root user
    - Sanitize the data
    - Use sql prepared statements
        -- Data must match  a specified data type
        -- Data cannt interfere
    - Use allow-list to validate data before using it in a query 

# Cross-site scripting 
    (When attacker injects code, primarily in html and javascript in webpage so that other users browser execute it)
        - 3 types of xss
            - Reflected (js code inject with url or form data, when page load script run immediately)
            - Stored (Malicious js stored in database, files, cookies, sessions. Runs later when data is retrieved)
            - DOM-based
                -- Data generated by js
                -- Runs when user triggers js events
                -- working with existing page

        - How to prevent xss
            - Write validations
            - Use allow-lists
            - Sanitize all data
                -- use html and javascript Sanitization
            - Use httpOnly cookies (prevent js from accessing cookies data)
            - Define a content security policy (a csp provides instructions to a browser about which types of resources can be used and which websites are allowed to provide them.)
                -- header response: Content-Security-Policy: script-src 'self' analytics.com(allowlist); object-src 'self';
                -- html meta: 
                <meta http-equiv="Content-Security-Policy" content="script-src 'self'; object-src 'self';">
                --- these example policy restrict script and plugin current domain only. it not permit remote loading js

# Cross-site request forgery (CSRF)
    - Cross-site (attack originate one site and send the request to another site)
    - request forgery (Request is not a genuine user request)

    * goal of CSRF
        - Increase page views for ad revenue
        - Ballot stuffing on polls
        - Change a user's password
        - Change a user's email address
        - log in to a site
        - Transfer funds
        - Download malware

    * Cross-site request protections
        - img tag always send a get request, so it will not do post request and post method url will be rejected.
        - csrf token
            1. Generate a long, unique, random string to be a token.
            2. Add the token to the user's session data.
            3. Add the token to the HTML form.
            4. When form data is received, compare the tokens.
            5. if the tokens match, then the form is valid. (Token could be only valid for a limited time period)

            -- CSRF defenses rely on having good xss defenses.
        
        - Other csrf defenses
            - Validate the HTTP referer header 
            - Add custom header to ajax XMLHttpRequest
            - Use Samesite cookie attribute
            - Protect Sensitive actions
                -- Confirmation page
                -- CAPTCHA images
                -- Reauthentication
            