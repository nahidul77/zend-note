# Types of Credentials attacks
    - Brute force attack
        maximum time required for brute-force attack is
        (Possibilities count ^ password length * time per attempt)
    - Dictionary attack (Prioritize the Dictionary word)
    - Credentials stuffing (common password accross the website)

# Strong Passwords

    - Use long passwords (12 characters minimum)
    - use character variety (A-Z, a-z, 0-9, symbols)
    - avoid patterns and Dictionary words
    - common mistake is short complex password is more secure than long simple one
    - Don't reuse password
    - Use password manager (LastPass, 1Password, Dashlane, KeePass)
    - Use ssh keys
    - two factor authentication
    - Use password hashing
    - Login Throttling (5 min wait after 10 failed attempts, prevent brute force attack)

# URL manipulation and insecure direct object reference (IDOR)

    * Url Manipulation
    - Searching for private webpages
    - Exploring the file system
    - Enumerating values in the database
    - Detecting installed software

    * Direct object reference
    - Database data
    - Files
    - Directories
    - Scripts
    - Functions

    * Preventing Insecure Direct object references
    - urls are exposed and easily editable
    - consider edge cases (expect the unexpected)
    - Use allow-lists for acceptable parameters 
    - Handle errors gracefully and vaguely
    - Use access control for privileged pages and actions
    - Change the direct object reference to an indirect 
    
# SQL injection
    
    * Solutions to sql injection
    - Limit the application's database privileges
    - Limit permission to create, drop, or truncate tables
    - Don't grant access privileges to database users
    - Never let the application connect as the root user
    - Sanitize the data
    - Use sql prepared statements
        -- Data must match  a specified data type
        -- Data cannt interfere
    - Use allow-list to validate data before using it in a query 

# Cross-site scripting 
    (When attacker injects code, primarily in html and javascript in webpage so that other users browser execute it)
        - 3 types of xss
            - Reflected (js code inject with url or form data, when page load script run immediately)
            - Stored (Malicious js stored in database, files, cookies, sessions. Runs later when data is retrieved)
            - DOM-based
                -- Data generated by js
                -- Runs when user triggers js events
                -- working with existing page

        - How to prevent xss
            - Write validations
            - Use allow-lists
            - Sanitize all data
                -- use html and javascript Sanitization
            - Use httpOnly cookies (prevent js from accessing cookies data)
            - Define a content security policy (a csp provides instructions to a browser about which types of resources can be used and which websites are allowed to provide them.)
                -- header response: Content-Security-Policy: script-src 'self' analytics.com(allowlist); object-src 'self';
                -- html meta: 
                <meta http-equiv="Content-Security-Policy" content="script-src 'self'; object-src 'self';">
                --- these example policy restrict script and plugin current domain only. it not permit remote loading js

# Cross-site request forgery (CSRF)
    - Cross-site (attack originate one site and send the request to another site)
    - request forgery (Request is not a genuine user request)

    * goal of CSRF
        - Increase page views for ad revenue
        - Ballot stuffing on polls
        - Change a user's password
        - Change a user's email address
        - log in to a site
        - Transfer funds
        - Download malware

    * Cross-site request protections
        - img tag always send a get request, so it will not do post request and post method url will be rejected.
        - csrf token
            1. Generate a long, unique, random string to be a token.
            2. Add the token to the user's session data.
            3. Add the token to the HTML form.
            4. When form data is received, compare the tokens.
            5. if the tokens match, then the form is valid. (Token could be only valid for a limited time period)

            -- CSRF defenses rely on having good xss defenses.
        
        - Other csrf defenses
            - Validate the HTTP referer header 
            - Add custom header to ajax XMLHttpRequest
            - Use Samesite cookie attribute
            - Protect Sensitive actions
                -- Confirmation page
                -- CAPTCHA images
                -- Reauthentication


# Cookie visibility and theft
    - Browser cookies easily viewed, manipulated and stolen. Cookie data also may be visible while in transit. cookie data sent as plain text in header of every request to the web server. attacker will see the cookies in open WIFI network. xss also used for to get cookie data.

    - Stealing cookies 
        -- Duplicate values (An attacker steals a cookie by placing the same values in a cookie on the attacker's browser)
        -- Forge a request (with cookie data as if it were their own)
        -- Modify values 

    - prevention
        -- httpOnly (make them unavailabe for js. the can not read the value by document.cookie anymore)
        -- Set SSL Certificate
        -- Use Secure cookies and domain , sub domain restriction

# Session Hijacking
    - Session Hijacking is an attack where a hacker steals a user's active session, to gain unauthorized access to parts of a website.
        1. Browser sends cookie with session ID.
        2. Server reads session ID.
        3. Server locates session file using session ID.
        4. Server looks for authentication data in session file.
        5. Server confirms authentication data.
        6. Server grants access to the requested page.
    
    - Prevent Cross-site scripting and keep cookie data secure
        - Validate input
        - Sanitize Output
        - Content Security Policy
        - Cookies settings: HttpOnly, Secure, Expire.
        - Use HTTPS
        - Mark the session cookie as secure
        - Expire and remove old sessions files regularly
        - Destroy sessions at logout
        - Regenerate session ID after login (Its invalidate any previously stolen session IDs, after successfully login)
    
    - Not recommended
        - Do not compare user agent strings
        - Do not compare IP addresses


# Session Fixation
    - The attacker provides a user with a valid session identifier. its similar to session haijacking but reversed. Instead of stealing a user's session ID. the attacker gives the user a session ID one that the attacker controls. user and attacker = Same session identifier

    - Prevent Session Fixation
        - Only accept session id from a cookie (Never accept session identifier a GET or POST variables).
        - Cross-site scripting defenses
        - Regenerate session ID after login

# Remote code Execution
   - RCE when an attacker can remotely execute internal operating system commands on a server. to put it another way, an attacker can type commands as if they were sitting at the keyboard.
    - Read, add, modify, delete files
    - Change access privileges, passwords
    - Turn on and off configuarations and services
    - Communicate to other servers

    * Common System Execution Functions
        - system, %x, exec, `` 
    
    - prevention
        - Avoid using them
        - Disable functions
        - Do not use dynamic data (if its necessary to use)
        - Sanitize data.


# File upload abuse
    - Abuses the public file upload features of a website

    * prevention
        - Only authenticating user can upload files
        - Do not make user-uploaded files available for public download
        - validation (size, type, max_file_size)
        - frequent file uploads limited


